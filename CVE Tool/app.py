from flask import Flask, request, render_template, send_file, redirect, url_for
import requests
from validate_cve import sanitize_cve_id, is_cve_exist
from io import BytesIO
from docx import Document
from selenium import webdriver
from selenium.webdriver.firefox.options import Options
from bs4 import BeautifulSoup
import time
import webbrowser
from answers import result
import google.generativeai as genai
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
from fpdf import FPDF

#########################Javid####################

app = Flask(__name__)

ans = []

google_api_key = 'AIzaSyCPkOoYP0rbbXzTHR42S4niFeSSEysBudI'
genai.configure(api_key=google_api_key)
model = genai.GenerativeModel('gemini-1.5-flash-latest')


@app.route('/message_email', methods = ['GET', 'POST'])
#Handles the email message request. If a POST request is made, it sends the results via email to the provided recipient address.
def message():
    if request.method == 'GET':
        return redirect(url_for('index'))
    result2 = result[::]
    recipient_email = request.form['email']
    send_message_body(result2[0], result2[1], result2[2], result2[3], result2[4], recipient_email, result2[5])
    return render_template('message.html')

@app.route('/add', methods=['GET', 'POST'])
#Processes the request to generate a file in the selected format. It then triggers the file generation and download.
def add():
    if request.method == 'GET':
        return redirect(url_for('index'))
    result2 = result[::]
    save_format = request.form['save_format']
    return generate_file(result2[0], result2[1], result2[2], result2[3], result2[4], save_format, None, result2[5])

@app.route('/', methods=['GET', 'POST'])
#The main page route that processes CVE ID inputs and fetches related data. Displays fetched CVE information, possible errors, and AI-generated content.
def index():
    cve_data_nvd = None
    cve_data_mitre = None
    exploit_db_links = None
    verified_exploits = None
    error_message = None
    cve_id = None
    ai_output = None
    
    if request.method == 'POST':
        cve_id = request.form['cve_id']
        sanitized_cve_id = sanitize_cve_id(cve_id)
        
        if sanitized_cve_id:
            if is_cve_exist(sanitized_cve_id):
                ai_output = generate_ai_content(cve_id)
                cve_data_nvd = fetch_cve_data(sanitized_cve_id)
                cve_data_mitre = get_cve(sanitized_cve_id)
                exploit_db_links = fetch_hyper_links(sanitized_cve_id)
                verified_exploits = get_verified_exploits(sanitized_cve_id)
                open_valid_hyperlinks(sanitized_cve_id)
                ans = [cve_data_nvd, cve_data_mitre, exploit_db_links, verified_exploits, sanitized_cve_id, ai_output]
                with open('answers.py', 'w',  encoding='utf-8') as file: # Copy
                    file.write(f"result = {ans}")
            else:
                error_message = "The CVE ID does not exist or has no data."
        else:
            error_message = (
                "Invalid CVE ID format. Please enter a valid CVE ID in the format 'CVE-YYYY-NNNN'. "
                "The year must be between 1999 and the current year, and the ID part must be 4 or more digits and cannot be all zeros. "
                "Example: CVE-2023-1234"
            )
    
    return render_template('index.html', cve_data_nvd=cve_data_nvd, cve_data_mitre=cve_data_mitre, 
                           exploit_db_links=exploit_db_links, verified_exploits=verified_exploits, 
                           cve_id=cve_id, error_message=error_message,ai_output=ai_output)

def generate_ai_content(cve_id):
#Uses the Generative AI model to create a summary of the CVE based on the provided CVE ID.
    prompt = (
        f"Provide a brief, factual summary of the CVE with ID {cve_id}. "
        f"The summary should be concise, containing only relevant information about the vulnerability, "
        f"and should not include any sensitive or potentially harmful content. "
        f"Limit the response to 4 to 5 sentences."
    )
    
    try:
        response = model.generate_content(prompt)
        time.sleep(10)
        
        if response and "text" in response:
            return response.text
        else:
            return "Content is sensitive or unable to generate response beacuse of security issues."
    except Exception as e:
        return f"An error occurred: {str(e)}"

def fetch_cve_data(cve_id):
#Retrieves CVE data from NVD (National Vulnerability Database) and filters relevant CVSS metrics and other details.
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    response = requests.get(url, headers={"apiKey":"2f4ac3ca-0910-40fc-a385-7e3d82360c03"})
    
    if response.status_code == 200:
        data = response.json()
        if data and 'vulnerabilities' in data:
            cve_item = data['vulnerabilities'][0]['cve']

            selected_metric_v31 = None
            selected_metric_v30 = None
            selected_metric_v2 = None
            
            # Check for the metric with source starting with 'nvd@nist.gov'
            metrics = cve_item.get('metrics', {})
            
            # Search for CVSS v3.1 metrics
            for metric in metrics.get('cvssMetricV31', []):
                if metric.get('source', '').startswith('nvd@nist.gov'):
                    selected_metric_v31 = metric
                    break
            
            # Search for CVSS v3.0 metrics
            for metric in metrics.get('cvssMetricV30', []):
                if metric.get('source', '').startswith('nvd@nist.gov'):
                    selected_metric_v30 = metric
                    break
            
            selected_metric_v2 = metrics.get('cvssMetricV2', [{}])[0]

            cvss_metrics_v31 = selected_metric_v31.get('cvssData', {}) if selected_metric_v31 else {}
            cvss_metrics_v30 = selected_metric_v30.get('cvssData', {}) if selected_metric_v30 else {}
            cvss_metrics_v2 = selected_metric_v2.get('cvssData', {}) if selected_metric_v2 else {}

            filtered_data = {
                "description": cve_item.get('descriptions', [{}])[0].get('value', 'N/A'),
                "severity_v31": cvss_metrics_v31.get('baseSeverity') if cvss_metrics_v31 else None,
                "exploitability_score_v31": cvss_metrics_v31.get('baseScore') if cvss_metrics_v31 else None,
                "severity_v30": cvss_metrics_v30.get('baseSeverity') if cvss_metrics_v30 else None,
                "exploitability_score_v30": cvss_metrics_v30.get('baseScore') if cvss_metrics_v30 else None,
                "severity_v2": selected_metric_v2.get('baseSeverity', 'N/A'),
                "exploitability_score_v2": cvss_metrics_v2.get('baseScore', 'N/A'),
                "cvss": cvss_metrics_v31.get('baseScore', cvss_metrics_v30.get('baseScore', cvss_metrics_v2.get('baseScore', 'N/A'))),
                "severity": cvss_metrics_v31.get('baseSeverity', cvss_metrics_v30.get('baseSeverity', cvss_metrics_v2.get('baseSeverity', 'N/A'))),
                "vector_string": cvss_metrics_v2.get('vectorString', 'N/A'),
                "version": cve_item.get('dataVersion', 'N/A'),
                "status": cve_item.get('publishedDate', 'N/A')
            }
            return filtered_data
        else:
            return {"error": "No data found"}
    else:
        return {"error": f"Unable to fetch data: {response.status_code}"}

def get_cve(cve_id):
#Fetches CVE metadata from MITRE’s CVE API and extracts information about the CVE’s state, vendor, and product.    
    url = f'https://cveawg.mitre.org/api/cve/{cve_id}'
    response = requests.get(url)
    
    if response.status_code == 200:
        data = response.json()
        state = data.get('cveMetadata', {}).get('state', 'Unknown')
        vendor = 'Unknown'
        product = 'Unknown'
        if data and 'containers' in data:
            affected = data['containers'].get('cna', {}).get('affected', [])
            if affected:
                vendor = affected[0].get('vendor', 'Unknown')
                product = affected[0].get('product', 'Unknown')
            
            if state == 'PUBLISHED':
                filtered_data = {
                    "state": state,
                    "vendor": vendor,
                    "product": product
                }
                if "tags" in data["containers"]["cna"] and data["containers"]["cna"]["tags"][0] == "disputed":
                    filtered_data["state"] = "DISPUTED"
            else:
                filtered_data = {
                    "state": state,
                }
            return filtered_data
        else:
            return {"error": "No data found"}
    else:
        return {"error": "Unable to fetch data"}

def fetch_hyper_links(cve_id):
#Gets a list of hyperlinks related to the CVE from NVD, specifically focusing on valid links for exploits.
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    try:
        response = requests.get(url)
        response.raise_for_status()
        
        cve_data = response.json()

        vulnerabilities = cve_data.get('vulnerabilities', {})
        exploit_db_links = []

        for vulnerability in vulnerabilities:
            references = vulnerability.get('cve', {}).get('references', {})
            for reference in references:
                tags = reference.get('tags', [])
                if tags:
                    link = reference.get('url')
                    if (link.startswith("https") and requests.get(link).status_code == 200) or link.startswith("https://exploit"):
                        exploit_db_links.append(link)
        return exploit_db_links

    except requests.exceptions.HTTPError as http_err:
        print(f"HTTP error occurred: {http_err}")
    except requests.exceptions.RequestException as req_err:
        print(f"Request error occurred: {req_err}")
    return []

##################################Yusif############################

def get_verified_exploits(cve_id):
#Uses Selenium to scrape verified exploit data from Exploit-DB for the given CVE ID.
    options = Options()
    options.add_argument('--headless')
    driver = webdriver.Firefox(options=options)
    
    try:
        url = f"https://www.exploit-db.com/search?cve={cve_id}"
        driver.get(url)

        time.sleep(3)

        soup = BeautifulSoup(driver.page_source, 'html.parser')
        table = soup.find('table', {'id': 'exploits-table'})
        if table:
            rows = table.find('tbody').find_all('tr')
            verified_exploits = []

            for row in rows:
                verified_icon = row.find('i', {'class': 'mdi-check'})
                if verified_icon:
                    title_tag = row.find('a', href=True)
                    title = title_tag.text.strip()
                    exploit_link = "https://www.exploit-db.com" + title_tag['href']
                    download_link = "https://www.exploit-db.com" + row.find('a', {'href': True})['href']
                    verified_exploits.append((title, exploit_link, download_link))

            return verified_exploits
        else:
            print("No exploits found for the provided CVE ID.")
            return []

    finally:
        driver.quit()

def open_valid_hyperlinks(cve_id):
#Opens up to five valid hyperlinks related to the CVE from NVD in the web browser.
    # Open the NVD URL
    nvd_url = f"https://nvd.nist.gov/vuln/detail/{cve_id}"
    
    # Open additional valid links from NVD
    try:
        response = requests.get(nvd_url)
        if response.status_code == 200:
            soup = BeautifulSoup(response.text, 'html.parser')
            hyperlinks = []
            
            table = soup.find('table', {'data-testid': 'vuln-hyperlinks-table'})
            if table:
                rows = table.find('tbody').find_all('tr')
                for row in rows:
                    link = row.find('a', href=True)['href']
                    full_link = link if link.startswith("http") else "https://" + link
                    if not is_link_broken(full_link):
                        hyperlinks.append(full_link)
                        if len(hyperlinks) == 5:  # Limit to opening up to 5 links
                            break
            
            for link in hyperlinks:
                webbrowser.open(link)
    except requests.RequestException as e:
        print(f"Request failed: {e}")
    
def is_link_broken(url):
#Checks if a given URL is broken by making a HEAD request and returning True if the status code indicates an error.
    try:
        response = requests.head(url, allow_redirects=True, timeout=5)
        return response.status_code >= 400
    except requests.RequestException:
        return True
    
######################Javid####################################

def send_message_to_email(receiver_email, title, body):
#Sends an email with the CVE report content to the specified recipient using SMTP.
    print("EMAIL")
    # Email details
    # SMTP server details
    sender_email = "memmedovcavid7621@gmail.com"
    smtp_server = "smtp.gmail.com"
    smtp_port = 587
    password = "YOUR PASSWORD"

    # Create the email
    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = receiver_email
    msg['Subject'] = title
    msg.attach(MIMEText(body, 'plain'))

    # Send the email
    try:
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(sender_email, password)
        server.sendmail(sender_email, receiver_email, msg.as_string())
        server.quit()
        return True
    except Exception:
        server.quit()
        return False

def generate_file(cve_data_nvd, cve_data_mitre, exploit_db_links, verified_exploits, cve_id, save_format, recipient_email, ai_output):
    """
    Generates a file in the selected format, sends it via email, and provides it for download.
    """
    # Formatting the data into a human-readable string
    content = (
        f"CVE Report for {cve_id}\n\n"
        f"NVD Data:\n"
        f"  - Description: {cve_data_nvd['description']}\n"
        f"  - CVSS Score: {cve_data_nvd['cvss']}\n"
        f"  - Severity: {cve_data_nvd['severity']}\n"
        f"  - Exploitability Score: {cve_data_nvd['exploitability_score_v31'] or cve_data_nvd['exploitability_score_v30'] or cve_data_nvd['exploitability_score_v2']}\n"
        f"  - Vector String: {cve_data_nvd['vector_string']}\n"
        f"  - Version: {cve_data_nvd['version']}\n"
        f"  - Status: {cve_data_nvd['status']}\n\n"
        f"  - AI: {ai_output}\n\n"
        f"Mitre Data:\n"
        f"  - State: {cve_data_mitre['state']}\n"
        f"  - Vendor: {cve_data_mitre.get('vendor', 'N/A')}\n"
        f"  - Product: {cve_data_mitre.get('product', 'N/A')}\n\n"
        f"Exploit-DB Links:\n"
    )
    
    if exploit_db_links:
        for link in exploit_db_links:
            content += f"  - {link}\n"
    else:
        content += "  - No Exploit-DB links found.\n"
    
    if verified_exploits:
        content += "\nVerified Exploits:\n"
        for title, exploit_link, download_link in verified_exploits:
            content += f"  - {title}\n"
            # content += f"    Exploit Link: {exploit_link}\n"
            content += f"    Download Link: {download_link}\n"
    else:
        content += "  - No verified exploits found.\n"

    if save_format == 'docx':
        doc = Document()
        doc.add_heading(f"CVE Report for {cve_id}", 0)
        doc.add_paragraph(content)
        byte_io = BytesIO()
        doc.save(byte_io)
        byte_io.seek(0)
        return send_file(byte_io, as_attachment=True, download_name=f'{cve_id}.docx')
    
    elif save_format == 'pdf':
        # Create a PDF file
        pdf = FPDF()
        pdf.add_page()
        pdf.set_auto_page_break(auto=True, margin=15)
        pdf.set_font("Arial", size=12)

        # Add content to PDF
        pdf.multi_cell(0, 10, content)

        byte_io = BytesIO()
        pdf.output(dest='S').encode('latin1')  # Save PDF to BytesIO object
        byte_io.write(pdf.output(dest='S').encode('latin1'))
        byte_io.seek(0)

        return send_file(byte_io, as_attachment=True, download_name=f'{cve_id}.pdf')

    elif save_format == 'md':
        byte_io = BytesIO()
        byte_io.write(content.encode('utf-8'))
        byte_io.seek(0)
        return send_file(byte_io, as_attachment=True, download_name=f'{cve_id}.md')

    return "Error"


def send_message_body(cve_data_nvd, cve_data_mitre, exploit_db_links, verified_exploits, cve_id, recipient_email, ai_output):
    """
    Generates a file in the selected format, sends it via email, and provides it for download.
    """
    # Formatting the data into a human-readable string
    content = (
        f"CVE Report for {cve_id}\n\n"
        f"NVD Data:\n"
        f"  - Description: {cve_data_nvd['description']}\n"
        f"  - CVSS Score: {cve_data_nvd['cvss']}\n"
        f"  - Severity: {cve_data_nvd['severity']}\n"
        f"  - Exploitability Score: {cve_data_nvd['exploitability_score_v31'] or cve_data_nvd['exploitability_score_v30'] or cve_data_nvd['exploitability_score_v2']}\n"
        f"  - Vector String: {cve_data_nvd['vector_string']}\n"
        f"  - Version: {cve_data_nvd['version']}\n"
        f"  - Status: {cve_data_nvd['status']}\n\n"
        f"  - AI: {ai_output}\n\n"
        f"Mitre Data:\n"
        f"  - State: {cve_data_mitre['state']}\n"
        f"  - Vendor: {cve_data_mitre.get('vendor', 'N/A')}\n"
        f"  - Product: {cve_data_mitre.get('product', 'N/A')}\n\n"
        f"Exploit-DB Links:\n"
    )

    if exploit_db_links:
        for link in exploit_db_links:
            content += f"  - {link}\n"
    else:
        content += "  - No Exploit-DB links found.\n"
    
    if verified_exploits:
        content += "\nVerified Exploits:\n"
        for title, exploit_link, download_link in verified_exploits:
            content += f"  - {title}\n"
            # content += f"    Exploit Link: {exploit_link}\n"
            content += f"    Download Link: {download_link}\n"
    else:
        content += "  - No verified exploits found.\n"

    send_message_to_email(recipient_email, f'CVE Report for {cve_id}', content)

if __name__ == '__main__':
    app.run(debug=True)
